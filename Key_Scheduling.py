def Sub_Bytes(hex_element):#위에 선언한 Sub_Bytes_matrix와 달리 1바이트 16진수를 받아서 Sub Bytes 과정을 거친 결과를 리턴한다.
	S_Box = [['63','7c','77','7b','f2','6b','6f','c5','30','01','67','2b','fe','d7','ab','76'],
			 ['ca','82','c9','7d','fa','59','47','f0','ad','d4','a2','af','9c','a4','72','c0'],
			 ['b7','fd','93','26','36','3f','f7','cc','34','a5','e5','f1','71','d8','31','15'],
			 ['04','c7','23','c3','18','96','05','9a','07','12','80','e2','eb','27','b2','75'],
			 ['09','83','2c','1a','1b','6e','5a','a0','52','3b','d6','b3','29','e3','2f','84'],
			 ['53','d1','00','ed','20','fc','b1','5b','6a','cb','be','39','4a','4c','58','cf'],
			 ['d0','ef','aa','fb','43','4d','33','85','45','f9','02','7f','50','3c','9f','a8'],
			 ['51','a3','40','8f','92','9d','38','f5','bc','b6','da','21','10','ff','f3','d2'],
			 ['cd','0c','13','ec','5f','97','44','17','c4','a7','7e','3d','64','5d','19','73'],
			 ['60','81','4f','dc','22','2a','90','88','46','ee','b8','14','de','5e','0b','db'],
			 ['e0','32','3a','0a','49','06','24','5c','c2','d3','ac','62','91','95','e4','79'],
			 ['e7','c8','37','6d','8d','5d','4e','a9','6c','56','f4','ea','65','7a','ae','08'],
			 ['ba','78','25','2e','1c','a6','b4','c6','e8','dd','74','1f','4b','bd','8b','8a'],
			 ['70','3e','b5','66','48','03','f6','0e','61','35','57','b9','86','c1','1d','9e'],
			 ['e1','f8','98','11','69','d9','8e','94','9b','1e','87','e9','ce','55','28','df'],
			 ['8c','a1','89','0d','bf','e6','42','68','41','99','2d','0f','b0','54','bb','16']]

	if len(hex_element) != 2:				#S_box표에 대응될수 있도록 값을 변조 하는 부분
		hex_element = '0' + hex_element
	S_Box_row = int(hex_element[0],16)		#S-Box에서 행의 번호를 나타낼부분
	S_Box_column = int(hex_element[1],16)	#S-box에서 열의 번호를 나타낼부분
	Result = S_Box[S_Box_row][S_Box_column]	#S-box에서 대응된 값을 hex_matrix변수에 넣어주는과정
				
	return Result
	

def make_Round_key(key_matrix):#키스케줄 알고리즘을 통해 각 라운드에서 쓰이는 라운드 키를 만드는 함수.
	Rcon = [['01','02','04','08','10','20','40','80','1b','36'], #인자값으로 받은 키와 Xor 할 행렬 선언
			['00','00','00','00','00','00','00','00','00','00'],
			['00','00','00','00','00','00','00','00','00','00'],
			['00','00','00','00','00','00','00','00','00','00']]
	Round_key_matrix = []				#결과를 받을 리스트 선언
	Round_key_matrix.append(key_matrix)	#암호화 과정 제일 첫번째 과정에서 인자값으로 받은 키를 라운드0에 쓰는 키라고 생각하겠다.
										#왜냐하면 그 다음 라운드 키를 만드는 과정에서 그전의 키값 정보를 사용하기 때문이다.
	
	for Round in range(10):	#총 10라운드를 진행한다.
		tmp = []			#반복문 과정에서 임시로 결과를 저장할 리스트
		tmp1 = []			#3중리스트를 사용해서 Round_key_matrix[x][y][z]라하면 x는 라운드,y는 행,z는 열을 나타내준다.
		
		for x in range(4):	#각 라운드가 시작되고 구하려하는 라운드의 첫번째열은 다른열을 구하는 것과 달라서 구별해준다.
			Target = Round_key_matrix[Round][(1+x)%4][3]#한칸씩 밀어주는과정
			Target = Sub_Bytes(Target)					#타겟 즉,Xor연산을 거치려는 값을 S_box치환 해준다.
			Target = int(Target,16) 					#16진수를 10진수로 변환
			Result = int(Rcon[x][Round],16) ^ Target ^ int(Round_key_matrix[Round][x][0],16)
			Result = hex(Result)[2:]#hex함수 결과로 앞에 붙는 '0x'부분 날려준다.
			
			if len(Result) == 1:	#예를 들어 0x1 이라는 값을 일관성 있게 0x01 처럼 '0x'뒤의 자리수를 두자리로 맞춰준다.
				Result = '0' + Result
				
			tmp1.append(Result)		#tmp1에 그값을 추가한다.
			tmp.append(tmp1)		#tmp에 tmp1을 추가함으로써 tmp리스트는 리스트를 멤버로 가진다.
			tmp1 = []				#tmp1은 반복문을 돌때마다 새로운 값을 받아올 것 이므로 초기화를 해주는 과정.
			
		for column in range(3):	#현재 라운드에서의 첫번째 열은 위의 반복문에서 처리됬으므로 남은 3개의 열을 처리하는 과정.
			for row in range(4):#각 행의 번호를 바꿔가면서 값을 채운다.
				Result = int(tmp[row][column],16) ^ int(Round_key_matrix[Round][row][column+1],16)
				Result = hex(Result)[2:]
				tmp[row].append(Result)
	
		Round_key_matrix.append(tmp)
		
	return Round_key_matrix	

result = make_Round_key([['2b','28','ab','09'],
						 ['7e','ae','f7','cf'],
						 ['15','d2','15','4f'],
						 ['16','a6','88','3c']])
print(result)
